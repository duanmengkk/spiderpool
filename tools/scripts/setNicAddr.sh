#!/bin/bash

# Copyright 2025 Authors of spidernet-io
# SPDX-License-Identifier: Apache-2.0

:<<EOF
    INTERFACE="eth0" \
    IPV4_IP="10.0.2.15/24"  IPV4_GATEWAY="10.0.2.15" \
    MTU="1500" \
    ENABLE_POLICY_ROUTE="true" \
    ./setNicAddr.sh

    INTERFACE="eth1" \
    IPV4_IP="172.16.0.10/24"  IPV4_GATEWAY="172.16.0.1" \
    IPV6_IP="fd00::10/64"     IPV6_GATEWAY="fd00::1" \
    MTU="9000" \
    ENABLE_POLICY_ROUTE="true" \
    CUSTOM_ROUTE_TABLE="200" \
    CUSTOM_ROUTE_MARK="0x1100" \
    ./setNicAddr.sh


effect:
        root@single:~# ip rule
        0:	from all lookup local
        32765:	from all fwmark 0x1100 lookup 200
        32766:	from all lookup main
        32767:	from all lookup default

        root@single:~# iptables-save
        # Generated by iptables-save v1.8.7 on Mon May 26 21:09:35 2025
        *mangle
        :PREROUTING ACCEPT [0:0]
        :INPUT ACCEPT [0:0]
        :FORWARD ACCEPT [0:0]
        :OUTPUT ACCEPT [0:0]
        :POSTROUTING ACCEPT [0:0]
        -A PREROUTING -i eth0 -m conntrack --ctstate NEW -m comment --comment ensure_reply_packet_forwarded_by_eth0 -j CONNMARK --set-xmark 0x1100/0xffffffff
        -A OUTPUT -m comment --comment ensure_reply_packet_forwarded_by_eth0 -j CONNMARK --restore-mark --nfmask 0xffffffff --ctmask 0xffffffff
        COMMIT
        # Completed on Mon May 26 21:09:35 2025

        root@single:~# ip r show table 200
        default via 10.0.2.15 dev eth0

EOF

set -x

INTERFACE=${INTERFACE:-""}
IPV4_IP=${IPV4_IP:-""}
IPV4_GATEWAY=${IPV4_GATEWAY:-""}
IPV6_IP=${IPV6_IP:-""}
IPV6_GATEWAY=${IPV6_GATEWAY:-""}
MTU=${MTU:-""}
ENABLE_POLICY_ROUTE=${ENABLE_POLICY_ROUTE:-"false"}
CUSTOM_ROUTE_TABLE=${CUSTOM_ROUTE_TABLE:-""}
CUSTOM_ROUTE_MARK=${CUSTOM_ROUTE_MARK:-""}

# Only perform custom route setup if ENABLE_POLICY_ROUTE is true
if [ "${ENABLE_POLICY_ROUTE}" = "true" ]; then

    if [ -z "${IPV4_GATEWAY}" ]; then
        echo "ERROR: IPV4_GATEWAY is empty when ENABLE_POLICY_ROUTE is true"
        exit 1
    fi

    # Function to find available route table number
    find_available_table() {
        local start_table=$1
        local current_table=$start_table
        
        # Check if the table is already in use
        while ip route show table $current_table 2>/dev/null | grep -q .; do
            echo "Table $current_table is already in use, trying next one..."
            current_table=$((current_table + 1))
            # Avoid system reserved tables
            if [ $current_table -ge 253 ]; then
                current_table=100
            fi
        done
        
        CUSTOM_ROUTE_TABLE=$current_table
    }
    
    # Function to find available iptables mark
    find_available_mark() {
        local start_mark=$1
        local current_mark=$start_mark
        local decimal_mark=$(printf "%d" $current_mark)
        
        # Check if the mark is already in use in ip rule
        while ip rule list | grep -q "fwmark $current_mark"; do
            echo "Mark $current_mark is already in use, trying next one..."
            decimal_mark=$((decimal_mark + 1))
            current_mark=$(printf "0x%x" $decimal_mark)
        done
        
        CUSTOM_ROUTE_MARK=$current_mark
    }
    
    # Auto-detect available table number if not specified by user
    if [ -z "$CUSTOM_ROUTE_TABLE" ]; then
        find_available_table 200
    fi
    
    # Auto-detect available mark if not specified by user
    if [ -z "$CUSTOM_ROUTE_MARK" ]; then
        find_available_mark 0x1100
    fi
fi

[ -n "${INTERFACE}" ] || { echo "ERROR: INTERFACE is empty"; exit 1; }
echo "INTERFACE=${INTERFACE}"
echo "IPV4_IP=${IPV4_IP}"
echo "IPV4_GATEWAY=${IPV4_GATEWAY}"
echo "IPV6_IP=${IPV6_IP}"
echo "IPV6_GATEWAY=${IPV6_GATEWAY}"
echo "MTU=${MTU}"
echo "ENABLE_POLICY_ROUTE=${ENABLE_POLICY_ROUTE}"
echo "CUSTOM_ROUTE_TABLE=${CUSTOM_ROUTE_TABLE}"
echo "CUSTOM_ROUTE_MARK=${CUSTOM_ROUTE_MARK}"


#========
Config_IP=""
[ -n "$IPV4_IP" ] && \
Config_IP="       - \"${IPV4_IP}\""
[ -n "$IPV6_IP" ] && \
Config_IP="\
${Config_IP}
       - \"${IPV6_IP}\""

Config_gw=""
if [ "${ENABLE_POLICY_ROUTE}" = "false" ] ; then
if [ -n "$IPV4_GATEWAY" ] || [ -n "$IPV6_GATEWAY" ] ; then
Config_gw="      routes:"
[ -n "$IPV4_GATEWAY" ] && \
Config_gw="\
${Config_gw}
        - to: default
          via: ${IPV4_GATEWAY}
          metric: 10"
[ -n "$IPV6_GATEWAY" ] && \
Config_gw="\
${Config_gw}
        - to: default
          via: ${IPV6_GATEWAY}
          metric: 10"
fi
fi

[ -n "$MTU" ] && \
Config_MTU="\
      mtu: ${MTU}"

[ "$DHCP4" == "true" ] && \
DHCP_CONFIG="\
      dhcp4: true"


[ "$DHCP6" == "true" ] && \
DHCP_CONFIG+="\
      dhcp6: true"

cat <<EOF >/etc/netplan/12-${INTERFACE}.yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    ${INTERFACE}:
$( [ -n "${DHCP_CONFIG}" ] && echo "${DHCP_CONFIG}" )
$( [ -n "${DHCP_CONFIG}" ] || echo "      addresses:" )
$( [ -n "${Config_IP}" ] && echo "${Config_IP}" )
$( [ -n "${Config_gw}" ] && echo "${Config_gw}" )
$( [ -n "${Config_MTU}" ] && echo "${Config_MTU}" )
EOF

# Permissions for /etc/netplan/*.yaml are too open. Netplan configuration should NOT be accessible by others
chmod 600 /etc/netplan/*

#===================

# Generate custom routing script if requested
if [ "${ENABLE_POLICY_ROUTE}" = "true" ] ; then
    echo "Generating custom routing script for ${INTERFACE}"
    
    mkdir -p /etc/networkd-dispatcher/routable.d/
    SCRIPT_PATH="/etc/networkd-dispatcher/routable.d/${INTERFACE}-custom-route.sh"
    
    cat > "${SCRIPT_PATH}" << 'EOF'
#!/bin/bash

# This script is automatically generated by interface-netplan.sh
# It adds specific routing rules when the interface becomes routable
# Usage: script <interface> <state>
# Example: script eth0 routable

# Exit on error, but allow commands that check for existing rules to fail
set -e

EOF

    # Add configuration variables
    cat >> "${SCRIPT_PATH}" << EOF
SCRIPT_NAME="${INTERFACE}-custom-route.sh"

# Configuration variables
LOCAL_ETH_NAME="${INTERFACE}"
TABLE_NAME=${CUSTOM_ROUTE_TABLE}
GATEWAY=${IPV4_GATEWAY%/*}
IPTABLES_MARK=${CUSTOM_ROUTE_MARK}

# Log script execution with parameters
echo "[\$SCRIPT_NAME] Called with args: \$1 \$2"

# networkd-dispatcher passes interface name as first argument and state as second argument
# If run manually without arguments, use the configured interface name
if [ -n "\$1" ]; then
    IFACE="\$1"
    STATE="\$2"
    echo "[\$SCRIPT_NAME] Called with interface=\$IFACE state=\$STATE"
else
    IFACE="\${LOCAL_ETH_NAME}"
    STATE="manual"
    echo "[\$SCRIPT_NAME] No arguments provided, assuming interface=\$IFACE state=\$STATE"
fi

# Only proceed if this is for our configured interface and it's in routable state (or manual run)
if [ "\$IFACE" = "\${LOCAL_ETH_NAME}" ] && ([ "\$STATE" = "routable" ] || [ "\$STATE" = "manual" ]); then
    # Log the event
    echo "[\$SCRIPT_NAME] Interface \${LOCAL_ETH_NAME} became routable, checking and adding custom routing rules"
EOF

    # Add the check functions - using cat with variable escaping to ensure variables are preserved in the generated script
    cat >> "${SCRIPT_PATH}" << 'EOF'
    
    # Function to check if an iptables rule exists
    check_prerouting_rule() {
        iptables -t mangle -C PREROUTING -i ${LOCAL_ETH_NAME} -m conntrack --ctstate NEW -j CONNMARK --set-mark ${IPTABLES_MARK} -m comment --comment "ensure_reply_packet_forwarded_by_${LOCAL_ETH_NAME}" &>/dev/null
        return $?
    }
    
    check_output_rule() {
        iptables -t mangle -C OUTPUT -j CONNMARK --restore-mark -m comment --comment "ensure_reply_packet_forwarded_by_${LOCAL_ETH_NAME}" &>/dev/null
        return $?
    }
    
    # Add iptables rule to mark new connections from interface if it doesn't exist
    if ! check_prerouting_rule; then
        echo "[${SCRIPT_NAME}] Adding iptables PREROUTING rule for ${LOCAL_ETH_NAME}"
        iptables -t mangle -A PREROUTING -i ${LOCAL_ETH_NAME} -m conntrack --ctstate NEW -j CONNMARK --set-mark ${IPTABLES_MARK} -m comment --comment "ensure_reply_packet_forwarded_by_${LOCAL_ETH_NAME}"
    else
        echo "[${SCRIPT_NAME}] iptables PREROUTING rule for ${LOCAL_ETH_NAME} already exists"
    fi
    
    # Add iptables rule to restore connection mark if it doesn't exist
    if ! check_output_rule; then
        echo "[${SCRIPT_NAME}] Adding iptables OUTPUT rule for connection mark restoration"
        iptables -t mangle -A OUTPUT -j CONNMARK --restore-mark -m comment --comment "ensure_reply_packet_forwarded_by_${LOCAL_ETH_NAME}"
    else
        echo "[${SCRIPT_NAME}] iptables OUTPUT rule for connection mark restoration already exists"
    fi
    
    # Check if IP rule for marked packets exists
    if ! ip rule list | grep -q "from all fwmark ${IPTABLES_MARK} lookup ${TABLE_NAME}"; then
        echo "[${SCRIPT_NAME}] Adding IP rule for marked packets"
        ip rule add fwmark ${IPTABLES_MARK} table ${TABLE_NAME}
    else
        echo "[${SCRIPT_NAME}] IP rule for marked packets already exists"
    fi
    
    # Check if default route exists in the routing table
    if ! ip route show table ${TABLE_NAME} | grep -q "default via ${GATEWAY} dev ${LOCAL_ETH_NAME}"; then
        echo "[${SCRIPT_NAME}] Adding default route via ${GATEWAY} table ${TABLE_NAME}"
        ip route add default via ${GATEWAY} dev ${LOCAL_ETH_NAME} table ${TABLE_NAME}
    else
        echo "[${SCRIPT_NAME}] Default route via ${GATEWAY} table ${TABLE_NAME} already exists"
    fi
    
    echo "[${SCRIPT_NAME}] Custom routing rules for ${LOCAL_ETH_NAME} have been checked and updated"
fi

exit 0
EOF

    # Make the script executable
    chmod +x "${SCRIPT_PATH}"
    echo "Created custom routing script: ${SCRIPT_PATH}"
    
fi

# Apply netplan configuration
netplan apply

